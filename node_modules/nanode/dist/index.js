"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var axios_1 = require("axios");
var accountPair = require('./util/util.js').accountPair;
var converter_1 = require("./util/converter");
exports.NanodeRepresentative = 'xrb_1nanode8ngaakzbck8smq6ru9bethqwyehomf79sae1k7xd47dkidjqzffeg';
exports.BounceAddress = '';
function createAPI(rpcClient) {
    return function callRPC(action, body) {
        return __awaiter(this, void 0, void 0, function () {
            var params;
            return __generator(this, function (_a) {
                params = Object.assign({}, body || {}, { action: action });
                return [2 /*return*/, rpcClient(params)];
            });
        });
    };
}
function createAxiosClient(apiKey, baseURL) {
    if (baseURL === void 0) { baseURL = 'https://api.nanode.co/'; }
    var headers = apiKey ? { Authorization: apiKey } : {};
    var rpc = axios_1.default.create({
        baseURL: baseURL,
        headers: headers
    });
    return function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, rpc.post('/', params)];
                    case 1:
                        data = (_a.sent()).data;
                        return [2 /*return*/, data];
                }
            });
        });
    };
}
exports.createAxiosClient = createAxiosClient;
var Nano = /** @class */ (function () {
    function Nano(options) {
        this.rpc = createAPI(null);
        this.debug = !!options.debug;
        if (options.rpcClient) {
            this.rpc = createAPI(options.rpcClient);
        }
        else {
            var rpcClient = createAxiosClient(options.apiKey, options.url);
            this.rpc = createAPI(rpcClient);
        }
        this._log = this._log.bind(this);
    }
    Nano.prototype._log = function (message) {
        if (this.debug) {
            console.log(message);
        }
    };
    Nano.prototype.account = function (private_key) {
        var _this = this;
        var address = accountPair(private_key).address;
        return {
            open: function (respresentative, hash) {
                return _this.open(private_key, respresentative, hash);
            },
            send: function (amount, address) {
                return _this.send(private_key, amount, address);
            },
            receive: function (hash) {
                return _this.receive(private_key, hash);
            },
            change: function (representative) {
                return _this.change(private_key, representative);
            },
            rawBalance: function () {
                return _this.accounts.rawBalance(address);
            },
            nanoBalance: function () {
                return _this.accounts.nanoBalance(address);
            },
            blockCount: function () {
                return _this.accounts.blockCount(address);
            },
            history: function (count) {
                return _this.accounts.history(address, count);
            },
            info: function () {
                return _this.accounts.info(address);
            },
            publicKey: function () {
                return _this.accounts.key(address);
            },
            ledger: function (count, details) {
                return _this.accounts.ledger(address, count, details);
            },
            pending: function (count, threshold) {
                return _this.accounts.pending(address, count, threshold);
            },
            representative: function () {
                return _this.accounts.representative(address);
            },
            weight: function () {
                return _this.accounts.weight(address);
            }
        };
    };
    //Top-level call: open block
    Nano.prototype.open = function (privateKey, representative, sendBlockHash) {
        return __awaiter(this, void 0, void 0, function () {
            var _log, _a, address, publicKey, work, res, block, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _log = this._log;
                        if (!privateKey) {
                            throw new Error('Must pass privateKey argument');
                        }
                        if (!representative) {
                            representative = exports.NanodeRepresentative;
                        }
                        _a = accountPair(privateKey), address = _a.address, publicKey = _a.publicKey;
                        return [4 /*yield*/, this.work.generate(publicKey)];
                    case 1:
                        work = (_b.sent()).work;
                        if (!!sendBlockHash) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.accounts.pending(address, 1)];
                    case 2:
                        res = _b.sent();
                        if (!res.blocks || res.blocks.length === 0) {
                            throw new Error('This account has no pending blocks to receive');
                        }
                        sendBlockHash = res.blocks[0];
                        _b.label = 3;
                    case 3: return [4 /*yield*/, this.blocks.createOpen({
                            previous: publicKey,
                            key: privateKey,
                            source: sendBlockHash,
                            work: work,
                            representative: representative
                        })];
                    case 4:
                        block = _b.sent();
                        return [4 /*yield*/, this.blocks.publish(block.block)];
                    case 5:
                        result = _b.sent();
                        _log("Opened NANO account " + address + " with block " + result.hash + " and representative " + representative + "!");
                        return [2 /*return*/, result];
                }
            });
        });
    };
    //Top-level call: send block
    Nano.prototype.send = function (privateKey, amount, toAddress) {
        return __awaiter(this, void 0, void 0, function () {
            var _log, _a, balance, frontier, work, amountRaw, block, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _log = this._log;
                        if (!privateKey) {
                            throw new Error('Must pass private_key argument');
                        }
                        return [4 /*yield*/, this.generateLatestWork(privateKey)];
                    case 1:
                        _a = _b.sent(), balance = _a.balance, frontier = _a.frontier, work = _a.work;
                        amountRaw = converter_1.default.unit(amount, 'NANO', 'raw');
                        return [4 /*yield*/, this.blocks.createSend({
                                key: privateKey,
                                destination: toAddress,
                                balance: balance,
                                amount: amountRaw,
                                previous: frontier,
                                work: work
                            })];
                    case 2:
                        block = _b.sent();
                        return [4 /*yield*/, this.blocks.publish(block.block)];
                    case 3:
                        result = _b.sent();
                        _log("Sent " + amountRaw + " raw to " + toAddress + "!");
                        return [2 /*return*/, result.hash];
                }
            });
        });
    };
    //Top-level call: receive block
    Nano.prototype.receive = function (privateKey, sendBlockHash) {
        return __awaiter(this, void 0, void 0, function () {
            var _log, _a, address, frontier, work, res, block, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _log = this._log;
                        if (!privateKey) {
                            throw new Error('Must pass privateKey argument');
                        }
                        return [4 /*yield*/, this.generateLatestWork(privateKey)];
                    case 1:
                        _a = _b.sent(), address = _a.address, frontier = _a.frontier, work = _a.work;
                        if (!!sendBlockHash) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.accounts.pending(address, 1)];
                    case 2:
                        res = _b.sent();
                        if (!res.blocks || res.blocks.length === 0) {
                            throw new Error('This account has no pending blocks to receive');
                        }
                        sendBlockHash = res.blocks[0];
                        _b.label = 3;
                    case 3: return [4 /*yield*/, this.blocks.createReceive({
                            key: privateKey,
                            previous: frontier,
                            work: work,
                            source: sendBlockHash
                        })];
                    case 4:
                        block = _b.sent();
                        return [4 /*yield*/, this.blocks.publish(block.block)];
                    case 5:
                        result = _b.sent();
                        _log("Received block " + sendBlockHash + " to wallet " + address + "!");
                        return [2 /*return*/, result];
                }
            });
        });
    };
    //Top-level call: change block
    Nano.prototype.change = function (privateKey, representative) {
        return __awaiter(this, void 0, void 0, function () {
            var _log, _a, frontier, work, block, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _log = this._log;
                        if (!privateKey) {
                            throw new Error('Must pass privateKey argument');
                        }
                        return [4 /*yield*/, this.generateLatestWork(privateKey)];
                    case 1:
                        _a = _b.sent(), frontier = _a.frontier, work = _a.work;
                        return [4 /*yield*/, this.blocks.createChange({
                                previous: frontier,
                                representative: representative,
                                work: work,
                                key: privateKey
                            })];
                    case 2:
                        block = _b.sent();
                        return [4 /*yield*/, this.blocks.publish(block.block)];
                    case 3:
                        result = _b.sent();
                        _log("Opened NANO block " + result.hash + " with rep. " + representative + "!");
                        return [2 /*return*/, result];
                }
            });
        });
    };
    Nano.prototype.generateLatestWork = function (privateKey) {
        return __awaiter(this, void 0, void 0, function () {
            var address, _a, balance, frontier, work;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        address = accountPair(privateKey).address;
                        return [4 /*yield*/, this.accounts.info(address)];
                    case 1:
                        _a = _b.sent(), balance = _a.balance, frontier = _a.frontier;
                        return [4 /*yield*/, this.work.generate(frontier)];
                    case 2:
                        work = (_b.sent()).work;
                        return [2 /*return*/, {
                                address: address,
                                balance: balance,
                                frontier: frontier,
                                work: work
                            }];
                }
            });
        });
    };
    Object.defineProperty(Nano.prototype, "accounts", {
        //General account methods
        get: function () {
            var _a = this, rpc = _a.rpc, _log = _a._log;
            return {
                get: function (publicKey) {
                    return rpc('account_get', { key: publicKey });
                },
                rawBalance: function (account) {
                    return rpc('account_balance', { account: account });
                },
                nanoBalance: function (account) {
                    return rpc('account_balance', { account: account }).then(function (balance) {
                        return converter_1.default.unit(balance.balance, 'raw', 'NANO');
                    });
                },
                balances: function (accounts) {
                    return rpc('accounts_balances', { accounts: accounts });
                },
                blockCount: function (account) {
                    return rpc('account_block_count', { account: account });
                },
                frontiers: function (accounts) {
                    return rpc('accounts_frontiers', { accounts: accounts });
                },
                history: function (account, count) {
                    return rpc('account_history', {
                        account: account,
                        count: count || 1000
                    }).then(function (res) { return res.history; });
                },
                info: function (account) {
                    return rpc('account_info', { account: account }).then(function (account) {
                        _log("(ACCOUNT) balance: " + account.balance);
                        _log("(ACCOUNT) latest hash: " + account.frontier);
                        return account;
                    });
                },
                key: function (account) {
                    return rpc('account_key', { account: account });
                },
                ledger: function (account, count, details) {
                    return rpc('ledger', {
                        account: account,
                        count: count || 1000,
                        representative: details,
                        weight: details,
                        pending: details
                    });
                },
                pending: function (account, count, minNanoThreshold) {
                    return rpc('pending', {
                        account: account,
                        threshold: converter_1.default.unit(minNanoThreshold || 0, 'NANO', 'raw'),
                        count: count || 1000
                    });
                },
                pendingMulti: function (accounts, count, minNanoThreshold) {
                    return rpc('accounts_pending', {
                        accounts: accounts,
                        threshold: converter_1.default.unit(minNanoThreshold || 0, 'NANO', 'raw'),
                        count: count || 1000
                    });
                },
                representative: function (account) {
                    return rpc('account_representative', {
                        account: account
                    }).then(function (res) { return res.representative; });
                },
                weight: function (account) {
                    return rpc('account_weight', { account: account }).then(function (res) { return res.weight; });
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Nano.prototype, "blocks", {
        get: function () {
            var _a = this, rpc = _a.rpc, _log = _a._log;
            return {
                account: function (hash) {
                    return rpc('block_account', { hash: hash }).then(function (res) { return res.account; });
                },
                count: function (byType) {
                    return byType ? rpc('block_count_type') : rpc('block_count');
                },
                chain: function (block, count) {
                    return rpc('chain', {
                        block: block,
                        count: count || 1000
                    }).then(function (res) { return res.blocks; });
                },
                createChange: function (block) {
                    return rpc('block_create', __assign({ type: 'change' }, block)).then(function (res) {
                        _log("(BLOCK) Changing " + block.key);
                        return res;
                    });
                },
                history: function (hash, count) {
                    return rpc('history', {
                        hash: hash,
                        count: count || 1000
                    });
                },
                //Get one or many block's information
                info: function (hashOrHashes, details) {
                    var getMulti = typeof hashOrHashes === 'array';
                    if (getMulti) {
                        return details
                            ? rpc('blocks_info', {
                                hashes: hashOrHashes
                            }).then(function (res) { return res.blocks; })
                            : rpc('blocks', {
                                hashes: hashOrHashes
                            }).then(function (res) { return res.blocks; });
                    }
                    else {
                        return rpc('block', {
                            hash: hashOrHashes
                        }).then(function (res) { return res.contents; });
                    }
                },
                createOpen: function (block) {
                    return rpc('block_create', __assign({ type: 'open' }, block)).then(function (res) {
                        _log("(BLOCK) Opening " + block.key);
                        return res;
                    });
                },
                pending: function (hash) {
                    return rpc('pending_exists', { hash: hash }).then(function (res) { return res.exists === '1'; });
                },
                publish: function (block) {
                    return rpc('process', { block: block }).then(function (res) {
                        _log("(BLOCK) Published: " + res.hash);
                        return res;
                    });
                },
                createReceive: function (block) {
                    return rpc('block_create', __assign({ type: 'receive' }, block)).then(function (res) {
                        _log("Received block " + block.source);
                        return res;
                    });
                },
                createSend: function (block) {
                    return rpc('block_create', __assign({ type: 'send' }, block)).then(function (res) {
                        _log("(BLOCK) Sending " + block.amount + " to " + block.destination);
                        return res;
                    });
                },
                successors: function (block, count) {
                    return rpc('successors', {
                        block: block,
                        count: count || 1000
                    });
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Nano.prototype, "convert", {
        get: function () {
            return {
                toRaw: function (amount, denomination) {
                    return converter_1.default.unit(amount, denomination, 'raw');
                },
                fromRaw: function (amount, denomination) {
                    return converter_1.default.unit(amount, 'raw', denomination);
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Nano.prototype, "delegators", {
        get: function () {
            var rpc = this.rpc;
            return {
                get: function (account) {
                    return rpc('delegators', { account: account }).then(function (res) { return res.delegators; });
                },
                count: function (account) {
                    return rpc('delegators_count', { account: account }).then(function (res) { return res.count; });
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Nano.prototype, "frontiers", {
        get: function () {
            var rpc = this.rpc;
            return {
                get: function (account, count) {
                    return rpc('frontiers', {
                        account: account,
                        count: count || 1000
                    });
                },
                count: function () {
                    return rpc('frontier_count').then(function (res) { return res.count; });
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Nano.prototype, "key", {
        get: function () {
            var rpc = this.rpc;
            // The word 'private' is reserved in JS so we use this function
            // to get around that, and to make 'address' more clear
            function convertKeyObj(keyObj) {
                return {
                    privateKey: keyObj.private,
                    publicKey: keyObj.public,
                    address: keyObj.account
                };
            }
            return {
                create: function () {
                    return rpc('key_create').then(convertKeyObj);
                },
                expand: function (privateKey) {
                    return rpc('key_expand', { key: privateKey }).then(convertKeyObj);
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Nano.prototype, "work", {
        //Generate and get work
        get: function () {
            var _a = this, rpc = _a.rpc, _log = _a._log;
            return {
                generate: function (hash) {
                    return rpc('work_generate', { hash: hash }).then(function (result) {
                        _log("(WORK) generated PoW: " + result.work);
                        return result;
                    });
                },
                validate: function (work, hash) {
                    return rpc('work_validate', { work: work, hash: hash });
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Nano.prototype.available = function () {
        return this.rpc('available_supply').then(function (res) { return res.available; });
    };
    Nano.prototype.representatives = function () {
        return this.rpc('representatives').then(function (res) { return res.representatives; });
    };
    Nano.prototype.deterministicKey = function (seed, index) {
        return this.rpc('deterministic_key', {
            seed: seed,
            index: index
        });
    };
    Object.defineProperty(Nano.prototype, "minimumReceive", {
        get: function () {
            var rpc = this.rpc;
            return {
                get: function () {
                    return rpc('receive_minimum');
                },
                set: function (nanoAmount) {
                    return rpc('receive_minimum_set', {
                        amount: converter_1.default.unit(nanoAmount, 'NANO', 'raw')
                    }).then(function (res) { return res.success === ''; });
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    return Nano;
}());
exports.Nano = Nano;
//# sourceMappingURL=index.js.map