import { API, SendBlock, ReceiveBlock, OpenBlock, ChangeBlock } from './api';
export declare const NanodeRepresentative = "xrb_1nanode8ngaakzbck8smq6ru9bethqwyehomf79sae1k7xd47dkidjqzffeg";
export declare const BounceAddress = "";
export declare type RPCClient = (params: any) => Promise<any>;
export declare function createAxiosClient(apiKey: string, baseURL?: string): RPCClient;
export interface NanoConstructorOptions {
    apiKey?: string;
    url?: string;
    rpcClient?: RPCClient;
    debug?: boolean;
}
export declare class Nano {
    rpc: <Action extends string>(action: Action, body?: API[Action]["body"]) => Promise<API[Action]["response"]>;
    debug: boolean;
    constructor(options: NanoConstructorOptions);
    _log(message: string): void;
    account(private_key: string): {
        open: (respresentative?: string, hash?: string) => Promise<{
            hash: string;
        }>;
        send: (amount: string | number, address: string) => Promise<string>;
        receive: (hash?: string) => Promise<{
            hash: string;
        }>;
        change: (representative: string) => Promise<{
            hash: string;
        }>;
        rawBalance: () => Promise<{
            balance: string;
            pending: string;
        }>;
        nanoBalance: () => Promise<string>;
        blockCount: () => Promise<{
            block_count: string;
        }>;
        history: (count?: number) => Promise<{
            type: string;
            account: string;
            hash: string;
            amount: string;
        }[]>;
        info: () => Promise<{
            frontier: string;
            open_block: string;
            representative_block: string;
            balance: string;
            modified_timestamp: string;
            block_count: string;
        }>;
        publicKey: () => Promise<{
            key: string;
        }>;
        ledger: (count?: number, details?: boolean) => Promise<{
            accounts: {
                [account: string]: {
                    frontier: string;
                    open_block: string;
                    representative_block: string;
                    balance: string;
                    modified_timestamp: string;
                    block_count: string;
                    representative?: string;
                    weight?: string;
                    pending?: string;
                };
            };
        }>;
        pending: (count?: number, threshold?: string) => Promise<{
            blocks: string[];
        }>;
        representative: () => Promise<string>;
        weight: () => Promise<string>;
    };
    open(privateKey: string, representative?: string, sendBlockHash?: string): Promise<{
        hash: string;
    }>;
    send(privateKey: string, amount: string | number, toAddress: string): Promise<string>;
    receive(privateKey: string, sendBlockHash?: string): Promise<{
        hash: string;
    }>;
    change(privateKey: string, representative: string): Promise<{
        hash: string;
    }>;
    generateLatestWork(privateKey: string): Promise<{
        address: any;
        balance: string;
        frontier: string;
        work: string;
    }>;
    readonly accounts: {
        get(publicKey: string): Promise<{
            account: string;
        }>;
        rawBalance(account: string): Promise<{
            balance: string;
            pending: string;
        }>;
        nanoBalance(account: string): Promise<string>;
        balances(accounts: string[]): Promise<{
            [account: string]: {
                balance: string;
                pending: string;
            };
        }>;
        blockCount(account: string): Promise<{
            block_count: string;
        }>;
        frontiers(accounts: string[]): Promise<{
            frontiers: {
                [account: string]: string;
            };
        }>;
        history(account: string, count?: number): Promise<{
            type: string;
            account: string;
            hash: string;
            amount: string;
        }[]>;
        info(account: string): Promise<{
            frontier: string;
            open_block: string;
            representative_block: string;
            balance: string;
            modified_timestamp: string;
            block_count: string;
        }>;
        key(account: string): Promise<{
            key: string;
        }>;
        ledger(account: string, count?: number, details?: boolean): Promise<{
            accounts: {
                [account: string]: {
                    frontier: string;
                    open_block: string;
                    representative_block: string;
                    balance: string;
                    modified_timestamp: string;
                    block_count: string;
                    representative?: string;
                    weight?: string;
                    pending?: string;
                };
            };
        }>;
        pending(account: string, count?: number, minNanoThreshold?: string | number): Promise<{
            blocks: string[];
        }>;
        pendingMulti(accounts: string[], count?: number, minNanoThreshold?: string | number): Promise<{
            blocks: {
                [account: string]: string;
            };
        }>;
        representative(account: string): Promise<string>;
        weight(account: string): Promise<string>;
    };
    readonly blocks: {
        account(hash: string): Promise<string>;
        count(byType?: boolean): Promise<{
            send: string;
            receive: string;
            open: string;
            change: string;
        }> | Promise<{
            count: number;
            unchecked: string;
        }>;
        chain(block: string, count?: number): Promise<any>;
        createChange(block: ChangeBlock): Promise<{
            hash: string;
            block: string;
        }>;
        history(hash: string, count?: number): Promise<{
            type: string;
            account: string;
            hash: string;
            amount: string;
        }[]>;
        info(hashOrHashes: string | string[], details?: boolean): Promise<{
            [account: string]: {
                contents: {
                    type: string;
                    account: string;
                    representative: string;
                    source: string;
                    work: string;
                    signature: string;
                };
                block_account: string;
                amount: string;
            };
        }> | Promise<{
            [account: string]: {
                type: string;
                account: string;
                representative: string;
                source: string;
                work: string;
                signature: string;
            };
        }> | Promise<{
            type: string;
            account: string;
            representative: string;
            source: string;
            work: string;
            signature: string;
        }>;
        createOpen(block: OpenBlock): Promise<{
            hash: string;
            block: string;
        }>;
        pending(hash: string): Promise<boolean>;
        publish(block: string): Promise<{
            hash: string;
        }>;
        createReceive(block: ReceiveBlock): Promise<{
            hash: string;
            block: string;
        }>;
        createSend(block: SendBlock): Promise<{
            hash: string;
            block: string;
        }>;
        successors(block: string, count?: number): Promise<{
            blocks: string[];
        }>;
    };
    readonly convert: {
        toRaw(amount: string | number, denomination: "mrai" | "krai" | "rai"): string;
        fromRaw(amount: string, denomination: "mrai" | "krai" | "rai"): string;
    };
    readonly delegators: {
        get(account: string): Promise<{
            [account: string]: string;
        }>;
        count(account: string): Promise<string>;
    };
    readonly frontiers: {
        get(account: string, count?: number): Promise<{
            frontiers: {
                [account: string]: string;
            };
        }>;
        count(): Promise<string>;
    };
    readonly key: {
        create(): Promise<{
            privateKey: string;
            publicKey: string;
            address: string;
        }>;
        expand(privateKey: string): Promise<{
            privateKey: string;
            publicKey: string;
            address: string;
        }>;
    };
    readonly work: {
        generate(hash: string): Promise<{
            work: string;
        }>;
        validate(work: string, hash: string): Promise<{
            valid: string;
        }>;
    };
    available(): Promise<string>;
    representatives(): Promise<{
        [account: string]: string;
    }>;
    deterministicKey(seed: string, index?: string | number): Promise<{
        private: string;
        public: string;
        account: string;
    }>;
    readonly minimumReceive: {
        get(): Promise<{
            amount: string;
        }>;
        set(nanoAmount: string | number): Promise<boolean>;
    };
}
